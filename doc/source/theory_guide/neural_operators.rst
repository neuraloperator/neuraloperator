.. _neuralop_intro:

=================================
Neural Operators: an Introduction
=================================


This guide introduces neural operators, a class of models that learn
mappings between function spaces and solve partial differential equations.
You can also check out the papers [1]_ [2]_ [3]_ for more formal derivations,
as well as the blog post [4]_.

Introduction
============

Scientific computations are often very costly in terms of time and resources.
For example, running numerical simulations of fluid dynamics or many-body systems 
can take days or even months.
This high cost is largely due to the need for numerical solvers to discretize 
space and time into extremely fine grids in order to achieve acceptable accuracy.
Solving the resulting large number of equations on these grids is computationally intensive.


To address these challenges, researchers have started to develop data-driven 
approaches using machine learning.
Rather than explicitly solving the equations for each new scenario, data-driven solvers are 
trained on data that pairs problems with their solutions.
Once trained, these solvers can quickly make predictions for new problems based on input data.
Because they do not require breaking the domain into tiny pieces and solving every equation 
from scratch, data-driven methods are often much faster than traditional numerical solvers.

However, data-driven solvers are subject to the quality of the input and training data.
If the training data is not good enough, they will learn to emulate that unreliable data 
and will not make good predictions.
In scientific computing, usually, the training data are generated by traditional numerical solvers, 
and it can still take days or months for these numerical solvers to generate good enough data.
In some cases, data are gathered directly from experiments, and high-quality training data 
may be unavailable. 

Neural networks are often regarded as powerful interpolators, but their ability to extrapolate 
to unseen scenarios remains uncertain. This raises questions about their capacity to generalize 
beyond the specific conditions represented in the training data. 
For example, if training data are generated at a particular resolution, the resulting 
learned models may only work effectively at that resolution. 
Overall, generalization is a fundamental challenge in machine learning. 
As a result, while machine learning-based methods can significantly speed up evaluation, 
the process of obtaining and preparing suitable training data can remain time-consuming and difficult.

To address this challenge, we introduce operator learning. By encoding appropriate structures,
we enable neural networks to learn mappings between functions and to generalize across 
ifferent discretizations.
This means we can use numerical methods to generate less-accurate, low-resolution data,
yet the trained solver can still produce accurate, high-resolution predictions.
As a result, both training and evaluation can become significantly more efficient and straightforward.

.. raw:: html

   <div style="margin-top: 3em;"></div>

Operator Learning
=================

In mathematics, the term "operator" commonly refers to a mapping between function spaces. 
You have likely encountered familiar operators such as differentiation and integration. 
Applying a derivative or performing an indefinite integration on a function transforms it into another function, 
which are both classic examples of operators acting on function spaces.

In scientific computing, the core challenge often involves solving differential equations, which inherently relate operators to function spaces. Consider a general differential equation of the form:

.. math::
    \mathcal{L}u = f

where  :math:`u` and :math:`f` are some functions on the physical domain, and
:math:`\mathcal{L}` is some differential operator that maps
the function :math:`u` to the function :math:`f`.
In most cases, :math:`\mathcal{L}` and :math:`f` are specified, and 
the objective is to find the solution :math:`u`.
Viewed from this perspective, solving a PDE is fundamentally an operator learning task: 
we wish to learn the mapping from input functions to solution functions.

Traditionally, neural networks have been designed to model mappings 
between finite-dimensional Euclidean spaces, such as classifying an image 
(represented as a vector of pixel intensities) into a label, or transforming one image vector into another. 
While effective for many tasks, this framework is inherently limited when addressing scientific 
and mathematical problems that require learning mappings between entire function spaces. 
In these cases, rather than learning simple vector-to-vector transformations, we seek to learn operators: 
transformations that act on functions and produce new functions, which is a more complex and general task.

This challenge is not restricted to the domain of differential equations; operator learning 
is implicit in many machine learning applications. 
For instance, even images can be more accurately viewed as continuous functions of light intensity 
over a spatial domain, rather than as discrete :math:`32 \times 32` pixel arrays. 
By embracing this perspective, we gain the flexibility to reason about, and learn mappings between, 
functions defined on arbitrary continuous domains, transcending the constraints of fixed discretizations.

We discuss how to generalize neural networks so that they can learn operators,
the mappings between infinite-dimensional spaces, with a special focus on PDEs.
For a comprehensive guide on principled approaches for extending neural architectures 
to function spaces for operator learning, see [3]_.

.. raw:: html

   <div style="margin-top: 3em;"></div>

Limitation of Fixed Discretization
==================================

Solving partial differential equations (PDEs) is a notoriously challenging task. 
Rather than working directly with operators on infinite-dimensional function spaces,
the standard approach is to discretize the physical domain and reformulate the problem in a finite-dimensional Euclidean setting.
Over the past century, this has led to the development of powerful numerical methods,
such as the finite element method and the finite difference method, which remain the cornerstone tools for PDE solution.

.. image:: /_static/images/grids.jpg
  :width: 800

Three examples of discretization:
The left one is a regular grid used in the finite difference method;
the middle one is a triangulated grid used in the finite element method;
the right one is a cylinder mesh for real-world airfoil problem.


Just like how we store images by pixels in *.PNG* and *.JPG* formats,
we need to discretize the domain of PDEs into some grid and solve the equation on the grid.
It really makes the thing easier.
These traditional numerical solvers are awesome, but they have some drawbacks:


- The error scales steeply with the resolution, so we often need a high resolution to get good approximations.
- The computation and storage steeply scale with the resolution (i.e. the size of the grid).
- When the equation is solved on one discretization, we cannot change the discretization anymore.


While formats like *.PNG* and *.JPG* are well-suited for storing images as grids of pixels, 
sometimes it's advantageous to use vector formats such as *.EPS* or *.SVG*, which represent images 
in a resolution-independent way and can be scaled or manipulated flexibly. 
For certain types of images, vector formats can be both more convenient and more efficient.

In the same spirit, when dealing with PDEs, we seek a representation that is not tied 
to any particular discretization, in other words, a continuous formulation of the problem. 
This means learning an operator that acts on functions directly and is invariant to the discretization, 
much like how a vector image can be displayed on any device at any resolution.

From a mathematical perspective, a continuous, discretization-invariant representation 
aligns more closely with the true analytic solution of a problem. 
This approach is not only conceptually elegant but also carries significant theoretical meaning. 
Keeping this motivation in mind, let us now build a rigorous mathematical framework.

.. raw:: html

   <div style="margin-top: 3em;"></div>

Problem Setting
===============

Consider the standard second order elliptic PDE

.. math::
    - \nabla \cdot (a(x) \nabla u(x))  = f(x), \quad  x \in D

.. math::
    u(x) = 0, \quad x \in \partial D

for some bounded, open domain :math:`D \subset \mathbb{R}^d` and a fixed source function
:math:`f`. This equation is prototypical of PDEs arising in
numerous applications including hydrology  and elasticity.
For a given function :math:`a`,
the equation has a unique weak solution :math:`u`
and therefore we can define the solution operator :math:`\mathcal{F}_{true}`
as the map from function to function :math:`a \mapsto u`.

Our goal is to learn a operator :math:`\mathcal{F}` approximating :math:`\mathcal{F}_{true}`,
by using a finite collection of observations of input-output pairs
:math:`\{a_j, u_j\}_{j=1}^N`, where each :math:`a_j` and :math:`u_j` are functions on :math:`D`.
In practice, the training data is solved numerically or observed in experiments.
In other words, functions :math:`a_j` and :math:`u_j` come with discretization.
Let :math:`P_K = \{x_1,\dots,x_K\} \subset D` be a :math:`K`-point discretization of the domain
:math:`D` and assume we have observations :math:`a_j|_{P_K}, u_j|_{P_K}`, for a finite
collection  of input-output pairs indexed by :math:`j`.


We will show how to learn a discretization-invariant mapping based on discretized data.

.. raw:: html

   <div style="margin-top: 3em;"></div>

Kernel Formulation
==================

For a general PDE of the form:

.. math::
    (\mathcal{L}_a u)(x)= f(x), \quad x \in D

.. math::
    u(x) = 0, \quad x \in \partial D.

Under fairly general conditions on :math:`\mathcal{L}_a`,
we may define the Green’s function :math:`G : D \times D \to \mathbb{R}` as the
unique solution to the problem

.. math::
    \mathcal{L}_a G(x, \cdot) = \delta_x

where :math:`\delta_x` is the delta measure on :math:`\mathbb{R}^d` centered at :math:`x`.
Note that :math:`G` will depend on the coefficient :math:`a` thus we will henceforth denote it as :math:`G_a`.
Then the true operator :math:`\mathcal{F}_{true}` can be written as an integral operator of Green’s function:

.. math::
    u(x) = \int_D G_a(x,y)f(y) \: dy.

Generally, the Green’s function is continuous at points :math:`x \neq y`,
for example, when :math:`\mathcal{L}_a` is uniformly elliptic.
Hence it is natural to model the kernel via a neural network :math:`\kappa`.
Just as the Green’s function, the kernel network :math:`\kappa` takes input :math:`(x,y)`.
Since the kernel depends on :math:`a`, we let :math:`\kappa` also take input :math:`(a(x),a(y))`, i.e.

.. math::
    u(x) = \int_D \kappa(x,y,a(x),a(y))f(y) \: dy.

.. raw:: html

   <div style="margin-top: 3em;"></div>

As an Iterative Solver
======================

In our setting, :math:`f` is an unknown but fixed function.
Instead of performing the kernel convolution with :math:`f`,
we will formulate it as an iterative solver
that approximates :math:`u` via :math:`u_t`,
where :math:`t = 0,\ldots,T` is the time step.

The algorithm starts from an initialization :math:`u_0`,
for which we use :math:`u_0(x) = (x, a(x))`.
At each time step :math:`t`, it updates :math:`u_{t+1}` via a kernel convolution of :math:`u_{t}`, i.e.

.. math::
    u_{t+1}(x) = \int_D \kappa(x,y,a(x),a(y))u_{t}(y) \: dy.

It works like an implicit iteration, where at each iteration the algorithm solves an equation 
for :math:`u_{t}(x)` and :math:`u_{t+1}(x)` using the kernel integral. 
:math:`u_T` will be output as the final prediction.

To further take the advantage of neural networks, we will lift :math:`u(x) \in \mathbb{R}^d`
to a high dimensional representation :math:`v(x) \in \mathbb{R}^n`,
with :math:`n` the dimension of the hidden representation.

The overall algorithmic framework follow:

.. math::
    v_0(x) = NN_1 (x, a(x))

.. math::
    v_{t+1}(x) = \sigma\Big( W v_t(x) + \int_{B(x,r)} \kappa_{\phi}\big(x,y,a(x),a(y)\big) v_t(y)\: \mathrm{d}y \Big) \quad \text{for } \ t=0,\ldots,T-1

.. math::
    u(x) = NN_2 (v_T (x))

where :math:`NN_1` and :math:`NN_2` are two feed-forward neural networks
that lifts the initialization to hidden representation :math:`v`
and projects the representation back to the solution :math:`u`, respectively.
:math:`\sigma` is an activation function such as ReLU.
The additional term :math:`W \in \mathbb{R}^{n \times n}` is a linear transformation
that acts on :math:`v`.


Notice that since the kernel integration happens in the high dimensional representation,
the output of :math:`\kappa_{\phi}` is not a scalar,
but a linear transformation :math:`\kappa_{\phi}\big(x,y,a(x),a(y)\big)\in \mathbb{R}^{n \times n}`.

.. raw:: html

   <div style="margin-top: 3em;"></div>

Graph Neural Networks
=====================

To perform the integration, we again need some discretization.
Assuming a uniform distribution of :math:`y`,
the integral :math:`\int_{B(x,r)} \kappa_{\phi}\big(x,y,a(x),a(y)\big)
v_t(y)\: \mathrm{d}y` can be approximated by a sum:

.. math::
    \frac{1}{|N(x)|}\sum_{y \in N(x)} \kappa(x,y,a(x),a(y))v_t(y).


Observation: The kernel integral is equivalent to message passing on graphs.


If you are familiar with graph neural networks,
you may have already realized this formulation is the same as
the aggregation of messages in graph networks.
Message passing graph networks comprise a standard architecture employing edge features
(Gilmer et al, 2017).

If we properly construct graphs on the spatial domain :math:`D` of the PDE,
the kernel integration can be viewed as an aggregation of messages.
Given node features :math:`v_t(x) \in \mathbb{R}^{n}`,
edge features :math:`e(x,y) \in \mathbb{R}^{n_e}`,
and a graph :math:`G`, the message passing neural network with averaging aggregation is

.. math::
    v_{t+1}(x) =  \sigma\Big(W v_t(x) + \frac{1}{|N(x)|} \sum_{y \in N(x)} \kappa_{\phi}\big(e(x,y)\big) v_t(y)\Big)

where :math:`W \in \mathbb{R}^{n \times n}`,
:math:`N(x)` is the neighborhood of :math:`x` according to the graph,
:math:`\kappa_{\phi}\big(e(x,y)\big)` is a neural network
taking edge features as input and as output
a matrix in :math:`\mathbb{R}^{n \times n}`.
Relating to our kernel formulation, :math:`e(x,y) = (x,y,a(x),a(y))`.

.. image:: /_static/images/graph.jpg
  :width: 800

.. raw:: html

   <div style="margin-top: 3em;"></div>

Nystrom Approximation
=====================

Ideally, to use all the information available,
we should construct :math:`K` nodes in the graph for all the points in the discretization
:math:`P_k = \{x_1,\ldots, x_K\}`, which will create :math:`O(K^2)` edges.
It is quite expensive.
Thankfully, we don’t need all the points to get an accurate approximation.
For each graph, the error of Monte Carlo approximation of the kernel integral

.. math::
    \int_{B(x,r)} \kappa_{\phi}(x, y, a(x), a(y)) v_t(y)\: \mathrm{d}y 

scales with :math:`m^{-1/2}`, where :math:`m` is the number of nodes sampled.

Since we will sample :math:`N` graphs in total for all :math:`N` training examples :math:`\{a_j, u_j\}^N`,
the overall error of the kernel is much smaller than :math:`m^{-1/2}`, where :math:`m` is the number of nodes sampled.
In practice, sampling :math:`m \sim 200` nodes is sufficient for :math:`K \sim 100,\!000` points.

The approximation can be further improved by employing advanced Nystrom methods.
For instance, by estimating the significance or influence of each point, 
we can strategically allocate more nodes to regions with high complexity or singularities in the PDEs, 
leading to greater accuracy where it matters most.

.. raw:: html

   <div style="margin-top: 3em;"></div>

Experiments: Poisson Equations
==============================

Let's first consider a simple Poisson equation:

.. math::
    -\Delta u = f.

We set :math:`v_0 = f` and :math:`T=1`, and use one iteration of the graph kernel network
to learn the operator :math:`\mathcal{F}: f \mapsto u`.

.. raw:: html

   <div style="margin-top: 3em;"></div>

Poisson equation
----------------

.. image:: /_static/images/nik_kernel.jpg
  :width: 800

As shown in the figure above, we compare the true analytic Green's function :math:`G(x,y)` (left)
with the learned kernel :math:`\kappa_{\phi}(x,y)`  (right).
The learned kernel is almost the same as the true kernel,
which means our neural network formulation matches the Green's function expression.

.. raw:: html

   <div style="margin-top: 3em;"></div>

2D Poisson equation
-------------------

.. image:: /_static/images/GKN_compare.jpg
  :width: 800

By assuming the kernel structure,
graph kernel networks need only a few training examples to learn the shape of the solution :math:`u`.
As shown in the figure above, the graph kernel network can roughly learn :math:`u` with :math:`5` training pairs,
while a feedforward neural network needs at least :math:`100` training examples.

.. raw:: html

   <div style="margin-top: 3em;"></div>

Experiments: generalization of resolution
=========================================


For the large scale experiments, we use the Darcy equation of the form

.. math::
    - \nabla \cdot (a(x) \nabla u(x))  = f(x), \quad  x \in D

.. math::
    u(x) = 0, \quad x \in \partial D

and learn the operator :math:`\mathcal{F}: a \mapsto u`.

To demonstrate the generalization property, we train the graph kernel network
with nodes sampled from the resolution :math:`s \times s`
and test on a different resolution :math:`s' \times s'` .


As shown in the table above for each row,
the test errors on different resolutions are about the same,
which means the graph kernel network can also
generalize in the semi-supervised setting.
A figure for :math:`s=16, s'=241` is shown below (where the error is the absolute squared error):

.. image:: /_static/images/uai_16to241.jpg
  :width: 800

.. raw:: html

   <div style="margin-top: 3em;"></div>

Conclusion
==========

We proposed using graph networks for operator learning in PDE problems.
By varying the underlying graph and discretization,
the learned kernel is invariant to the discretization.
Experiments confirm that the graph kernel networks are able to generalize among different discretizations.
And in the fixed discretization setting, the graph kernel networks 
also have good performance compared to several benchmarks.

.. raw:: html

   <div style="margin-top: 3em;"></div>

References
==========

.. [1] Neural operator: Graph kernel network for partial differential equations,
    Zongyi Li, Nikola Kovachki, Kamyar Azizzadenesheli, Burigede Liu, Kaushik Bhattacharya, Andrew Stuart, Anima Anandkumar

.. raw:: html

   <div style="margin-top: 1em"></div>

.. [2] Neural operator: Learning maps between function spaces,
    Nikola Kovachki, Zongyi Li, Kamyar Azizzadenesheli, Burigede Liu, Kaushik Bhattacharya, Andrew Stuart, Anima Anandkumar

.. raw:: html

   <div style="margin-top: 1em"></div>

.. [3] Principled Approaches for Extending Neural Architectures to Function Spaces for Operator Learning,
       Julius Berner, Miguel Liu-Schiaffini, Jean Kossaifi, Valentin Duruisseaux, 
       Boris Bonev, Kamyar Azizzadenesheli, Anima Anandkumar, 2025.
       arXiv:2506.10973. https://arxiv.org/abs/2506.10973

.. raw:: html

   <div style="margin-top: 1em"></div>

.. [4] Blog post by Zongyi Li, https://zongyi-li.github.io/blog/2020/graph-pde/
