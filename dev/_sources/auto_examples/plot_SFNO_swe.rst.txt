
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/plot_SFNO_swe.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_plot_SFNO_swe.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_plot_SFNO_swe.py:


Training a SFNO on the spherical Shallow Water equations
==========================================================

In this example, we demonstrate how to use the small Spherical Shallow Water Equations example we ship with the package
to train a Spherical Fourier-Neural Operator

.. GENERATED FROM PYTHON SOURCE LINES 11-24

.. code-block:: Python



    import torch
    import matplotlib.pyplot as plt
    import sys
    from neuralop.models import SFNO
    from neuralop import Trainer
    from neuralop.data.datasets import load_spherical_swe
    from neuralop.utils import count_model_params
    from neuralop import LpLoss, H1Loss

    device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')








.. GENERATED FROM PYTHON SOURCE LINES 25-26

Loading the Navier-Stokes dataset in 128x128 resolution

.. GENERATED FROM PYTHON SOURCE LINES 26-30

.. code-block:: Python

    train_loader, test_loaders = load_spherical_swe(n_train=200, batch_size=4, train_resolution=(32, 64),
                                                    test_resolutions=[(32, 64), (64, 128)], n_tests=[50, 50], test_batch_sizes=[10, 10],)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Loading train dataloader at resolution (32, 64) with 200 samples and batch-size=4
    Loading test dataloader at resolution (32, 64) with 50 samples and batch-size=10
    Loading test dataloader at resolution (64, 128) with 50 samples and batch-size=10




.. GENERATED FROM PYTHON SOURCE LINES 31-32

We create a tensorized FNO model

.. GENERATED FROM PYTHON SOURCE LINES 32-41

.. code-block:: Python


    model = SFNO(n_modes=(32, 32), in_channels=3, out_channels=3, hidden_channels=32, projection_channels=64, factorization='dense')
    model = model.to(device)

    n_params = count_model_params(model)
    print(f'\nOur model has {n_params} parameters.')
    sys.stdout.flush()






.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Our model has 278435 parameters.




.. GENERATED FROM PYTHON SOURCE LINES 42-43

Create the optimizer

.. GENERATED FROM PYTHON SOURCE LINES 43-49

.. code-block:: Python

    optimizer = torch.optim.Adam(model.parameters(), 
                                    lr=8e-4, 
                                    weight_decay=0.0)
    scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max=30)









.. GENERATED FROM PYTHON SOURCE LINES 50-51

Creating the losses

.. GENERATED FROM PYTHON SOURCE LINES 51-58

.. code-block:: Python

    l2loss = LpLoss(d=2, p=2, reduce_dims=(0,1))
    # h1loss = H1Loss(d=2, reduce_dims=(0,1))

    train_loss = l2loss
    eval_losses={'l2': l2loss} #'h1': h1loss, 









.. GENERATED FROM PYTHON SOURCE LINES 59-70

.. code-block:: Python



    print('\n### MODEL ###\n', model)
    print('\n### OPTIMIZER ###\n', optimizer)
    print('\n### SCHEDULER ###\n', scheduler)
    print('\n### LOSSES ###')
    print(f'\n * Train: {train_loss}')
    print(f'\n * Test: {eval_losses}')
    sys.stdout.flush()






.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    ### MODEL ###
     SFNO(
      (positional_embedding): GridEmbeddingND()
      (fno_blocks): FNOBlocks(
        (convs): SphericalConv(
          (weight): ModuleList(
            (0-3): 4 x ComplexDenseTensor(shape=torch.Size([32, 32, 32]), rank=None)
          )
          (sht_handle): SHT(
            (_SHT_cache): ModuleDict()
            (_iSHT_cache): ModuleDict()
          )
        )
        (fno_skips): ModuleList(
          (0-3): 4 x Flattened1dConv(
            (conv): Conv1d(32, 32, kernel_size=(1,), stride=(1,), bias=False)
          )
        )
      )
      (lifting): ChannelMLP(
        (fcs): ModuleList(
          (0): Conv1d(5, 256, kernel_size=(1,), stride=(1,))
          (1): Conv1d(256, 32, kernel_size=(1,), stride=(1,))
        )
      )
      (projection): ChannelMLP(
        (fcs): ModuleList(
          (0): Conv1d(32, 64, kernel_size=(1,), stride=(1,))
          (1): Conv1d(64, 3, kernel_size=(1,), stride=(1,))
        )
      )
    )

    ### OPTIMIZER ###
     Adam (
    Parameter Group 0
        amsgrad: False
        betas: (0.9, 0.999)
        capturable: False
        differentiable: False
        eps: 1e-08
        foreach: None
        fused: None
        initial_lr: 0.0008
        lr: 0.0008
        maximize: False
        weight_decay: 0.0
    )

    ### SCHEDULER ###
     <torch.optim.lr_scheduler.CosineAnnealingLR object at 0x7ff9888b9c70>

    ### LOSSES ###

     * Train: <neuralop.losses.data_losses.LpLoss object at 0x7ff9888ffac0>

     * Test: {'l2': <neuralop.losses.data_losses.LpLoss object at 0x7ff9888ffac0>}




.. GENERATED FROM PYTHON SOURCE LINES 71-72

Create the trainer

.. GENERATED FROM PYTHON SOURCE LINES 72-80

.. code-block:: Python

    trainer = Trainer(model=model, n_epochs=20,
                      device=device,
                      wandb_log=False,
                      eval_interval=3,
                      use_distributed=False,
                      verbose=True)









.. GENERATED FROM PYTHON SOURCE LINES 81-82

Actually train the model on our small Darcy-Flow dataset

.. GENERATED FROM PYTHON SOURCE LINES 82-92

.. code-block:: Python


    trainer.train(train_loader=train_loader,
                  test_loaders=test_loaders,
                  optimizer=optimizer,
                  scheduler=scheduler, 
                  regularizer=False, 
                  training_loss=train_loss,
                  eval_losses=eval_losses)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Training on 200 samples
    Testing on [50, 50] samples         on resolutions [(32, 64), (64, 128)].
    Raw outputs of shape torch.Size([4, 3, 32, 64])
    [0] time=3.48, avg_loss=2.2192, train_err=8.8767
    Eval: (32, 64)_l2=1.4341, (64, 128)_l2=2.6183
    [3] time=3.47, avg_loss=0.4502, train_err=1.8009
    Eval: (32, 64)_l2=0.4229, (64, 128)_l2=2.4382
    [6] time=3.48, avg_loss=0.3063, train_err=1.2250
    Eval: (32, 64)_l2=0.3283, (64, 128)_l2=2.4054
    [9] time=3.44, avg_loss=0.2549, train_err=1.0198
    Eval: (32, 64)_l2=0.2689, (64, 128)_l2=2.3475
    [12] time=3.45, avg_loss=0.2031, train_err=0.8124
    Eval: (32, 64)_l2=0.2613, (64, 128)_l2=2.3509
    [15] time=3.45, avg_loss=0.1749, train_err=0.6995
    Eval: (32, 64)_l2=0.2390, (64, 128)_l2=2.3383
    [18] time=3.46, avg_loss=0.1475, train_err=0.5900
    Eval: (32, 64)_l2=0.2243, (64, 128)_l2=2.3222

    {'train_err': 0.5922377383708954, 'avg_loss': 0.14805943459272386, 'avg_lasso_loss': None, 'epoch_train_time': 3.4545860709999943}



.. GENERATED FROM PYTHON SOURCE LINES 93-103

Plot the prediction, and compare with the ground-truth 
Note that we trained on a very small resolution for
a very small number of epochs
In practice, we would train at larger resolution, on many more samples.

However, for practicity, we created a minimal example that
i) fits in just a few Mb of memory
ii) can be trained quickly on CPU

In practice we would train a Neural Operator on one or multiple GPUs

.. GENERATED FROM PYTHON SOURCE LINES 103-138

.. code-block:: Python


    fig = plt.figure(figsize=(7, 7))
    for index, resolution in enumerate([(32, 64), (64, 128)]):
        test_samples = test_loaders[resolution].dataset
        data = test_samples[0]
        # Input x
        x = data['x']
        # Ground-truth
        y = data['y'][0, ...].numpy()
        # Model prediction
        x_in = x.unsqueeze(0).to(device)
        out = model(x_in).squeeze()[0, ...].detach().cpu().numpy()
        x = x[0, ...].detach().numpy()

        ax = fig.add_subplot(2, 3, index*3 + 1)
        ax.imshow(x)
        ax.set_title(f'Input x {resolution}')
        plt.xticks([], [])
        plt.yticks([], [])

        ax = fig.add_subplot(2, 3, index*3 + 2)
        ax.imshow(y)
        ax.set_title('Ground-truth y')
        plt.xticks([], [])
        plt.yticks([], [])

        ax = fig.add_subplot(2, 3, index*3 + 3)
        ax.imshow(out)
        ax.set_title('Model prediction')
        plt.xticks([], [])
        plt.yticks([], [])

    fig.suptitle('Inputs, ground-truth output and prediction.', y=0.98)
    plt.tight_layout()
    fig.show()



.. image-sg:: /auto_examples/images/sphx_glr_plot_SFNO_swe_001.png
   :alt: Inputs, ground-truth output and prediction., Input x (32, 64), Ground-truth y, Model prediction, Input x (64, 128), Ground-truth y, Model prediction
   :srcset: /auto_examples/images/sphx_glr_plot_SFNO_swe_001.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (1 minutes 26.227 seconds)


.. _sphx_glr_download_auto_examples_plot_SFNO_swe.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_SFNO_swe.ipynb <plot_SFNO_swe.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_SFNO_swe.py <plot_SFNO_swe.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_SFNO_swe.zip <plot_SFNO_swe.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
