from typing import List

import torch
from torch.utils.data import Dataset

from .base_transforms import Transform
from ...training.patching import MultigridPatching2D


class MGPatchingTransform(Transform):
    """Wraps MultigridPatching2D to expose canonical
    transform .transform() and .inverse_transform() API

    Parameters
    ----------
    model: nn.Module
        model to wrap in MultigridPatching2D
    levels : int
        mg_patching level parameter for MultigridPatching2D
    padding_fraction : float
        mg_padding_fraction parameter for MultigridPatching2D
    stitching : float
        mg_patching_stitching parameter for MultigridPatching2D
    """

    def __init__(
        self,
        model: torch.nn.Module,
        levels: int,
        padding_fraction: float,
        stitching: float,
    ):
        """Initialize the MGPatchingTransform.

        See class docstring for detailed parameter descriptions.
        """
        super.__init__()

        self.levels = levels
        self.padding_fraction = padding_fraction
        self.stitching = stitching
        self.patcher = MultigridPatching2D(
            model=model,
            levels=self.levels,
            padding_fraction=self.padding_fraction,
            stitching=self.stitching,
        )

    def transform(self, data_dict):
        x = data_dict["x"]
        y = data_dict["y"]

        x, y = self.patcher.patch(x, y)

        data_dict["x"] = x
        data_dict["y"] = y
        return data_dict

    def inverse_transform(self, data_dict):
        x = data_dict["x"]
        y = data_dict["y"]

        x, y = self.patcher.unpatch(x, y)

        data_dict["x"] = x
        data_dict["y"] = y
        return data_dict

    def to(self, _):
        # nothing to pass to device
        return self


class RandomMGPatch:
    def __init__(self, levels=2):
        self.levels = levels
        self.step = 2**levels

    def __call__(self, data):
        def _get_patches(shifted_image, step, height, width):
            """Take as input an image and return multi-grid patches centered around the middle of the image"""
            if step == 1:
                return (shifted_image,)
            else:
                # Notice that we need to stat cropping at start_h = (height - patch_size)//2
                # (//2 as we pad both sides)
                # Here, the extracted patch-size is half the size so patch-size = height//2
                # Hence the values height//4 and width // 4
                start_h = height // 4
                start_w = width // 4

                patches = _get_patches(shifted_image[:, start_h:-start_h, start_w:-start_w], step//2, height//2, width//2)

                return (shifted_image[:, ::step, ::step], *patches)

        x, y = data
        channels, height, width = x.shape
        center_h = height // 2
        center_w = width // 2

        # Sample a random patching position
        pos_h = torch.randint(low=0, high=height, size=(1,))[0]
        pos_w = torch.randint(low=0, high=width, size=(1,))[0]

        shift_h = center_h - pos_h
        shift_w = center_w - pos_w

        shifted_x = torch.roll(x, (shift_h, shift_w), dims=(0, 1))
        patches_x = _get_patches(shifted_x, self.step, height, width)
        shifted_y = torch.roll(y, (shift_h, shift_w), dims=(0, 1))
        patches_y = _get_patches(shifted_y, self.step, height, width)

        return torch.cat(patches_x, dim=0), patches_y[-1]


class MGPTensorDataset(Dataset):
    def __init__(self, x, y, levels=2):
        assert x.size(0) == y.size(0), "Size mismatch between tensors"
        self.x = x
        self.y = y
        self.levels = 2
        self.transform = RandomMGPatch(levels=levels)

    def __getitem__(self, index):
        return self.transform((self.x[index], self.y[index]))

    def __len__(self):
        return self.x.size(0)
