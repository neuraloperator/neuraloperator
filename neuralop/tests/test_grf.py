import torch
import numpy as np
import pytest
from torch.testing import assert_close

from ..grf import RBFKernelSampler, MaternKernelSampler


class TestRBFKernelSampler:
    @pytest.mark.parametrize("device", [torch.device("cpu")])
    @pytest.mark.parametrize("in_channels", [1, 2])
    @pytest.mark.parametrize("grid_size", [(32, 32), (64, 60)])
    def test_rbf_sampler_output_shape(self, device, in_channels, grid_size):
        """Test RBF sampler output shape"""
        Ln1, Ln2 = grid_size
        sampler = RBFKernelSampler(
            in_channels=in_channels,
            Ln1=Ln1,
            Ln2=Ln2,
            scale=0.1,
            device=device,
        )

        N = 4
        samples = sampler.sample(N)
        expected_shape = (N, in_channels, Ln1, Ln2)
        assert samples.shape == expected_shape
        assert samples.device == device

    def test_rbf_sampler_normalization(self):
        """Test that RBF sampler produces samples with zero mean and unit std"""
        sampler = RBFKernelSampler(
            in_channels=1,
            Ln1=64,
            Ln2=64,
            scale=0.1,
        )

        # Generate enough samples for reliable statistics
        N = 500
        samples = sampler.sample(N)

        # Calculate statistics
        mean = samples.mean().item()
        std = samples.std().item()

        # Mean should be approximately zero (within tolerance due to randomness)
        assert abs(mean) < 0.01, f"Expected mean ≈ 0, got {mean}"

        # Standard deviation should be approximately 1
        assert abs(std - 1.0) < 0.01, f"Expected std ≈ 1, got {std}"


class TestMaternKernelSampler:
    @pytest.mark.parametrize("device", [torch.device("cpu")])
    @pytest.mark.parametrize("in_channels", [1, 2])
    def test_matern_sampler_output_shape(self, device, in_channels):
        """Test Matern sampler output shape with appropriate grid sizes for each boundary condition"""
        # Test zero-neumann with square grid only
        sampler_zn = MaternKernelSampler(
            in_channels=in_channels,
            Ln1=64,
            Ln2=64,
            scale=0.1,
            nu=2.5,
            boundary_condition="zero-neumann",
            device=device,
        )

        N = 4
        samples_zn = sampler_zn.sample(N)
        expected_shape_zn = (N, in_channels, 64, 64)
        assert samples_zn.shape == expected_shape_zn
        assert samples_zn.device == device

        # Test periodic and none with various grid sizes
        for boundary_condition in ["periodic", "none"]:
            for grid_size in [(32, 32), (64, 60)]:
                Ln1, Ln2 = grid_size
                sampler = MaternKernelSampler(
                    in_channels=in_channels,
                    Ln1=Ln1,
                    Ln2=Ln2,
                    scale=0.1,
                    nu=2.5,
                    boundary_condition=boundary_condition,
                    device=device,
                )

                samples = sampler.sample(N)
                expected_shape = (N, in_channels, Ln1, Ln2)
                assert samples.shape == expected_shape
                assert samples.device == device

    @pytest.mark.parametrize("boundary_condition", ["zero-neumann", "periodic", "none"])
    def test_matern_sampler_normalization(self, boundary_condition):
        """Test normalization functionality"""
        sampler_norm = MaternKernelSampler(
            in_channels=1,
            Ln1=64,
            Ln2=64,
            scale=0.1,
            nu=2.5,
            normalize_std=True,
            boundary_condition=boundary_condition,
        )

        samples_norm = sampler_norm.sample(100)
        std_norm = samples_norm.std().item()

        # Should be approximately 1 due to normalization
        assert abs(std_norm - 1.0) < 0.01

    @pytest.mark.parametrize("boundary_condition", ["zero-neumann", "periodic", "none"])
    def test_matern_sampler_reproducibility(self, boundary_condition):
        """Test that sampler produces consistent results with same random seed"""
        sampler = MaternKernelSampler(
            in_channels=1,
            Ln1=64,
            Ln2=64,
            scale=0.1,
            nu=2.5,
            boundary_condition=boundary_condition,
        )

        # Set seed and sample
        torch.manual_seed(42)
        samples1 = sampler.sample(2)

        # Reset seed and sample again
        torch.manual_seed(42)
        samples2 = sampler.sample(2)

        assert_close(samples1, samples2)


@pytest.mark.parametrize("boundary_condition", ["zero-neumann", "periodic", "none"])
def test_matern_sampler_covariance(boundary_condition):
    """
    Test that compares Matern kernel GRF generated by covariance function definition
    with the existing spectral method by analyzing their average spectral energy.
    """
    import numpy as np
    from scipy.spatial.distance import cdist
    from scipy.special import kv, gamma
    from scipy.fft import fft2, fftshift

    def matern_kernel_covariance(d, length_scale, nu):
        """
        Computes the Matern covariance function using the mathematical definition.

        Args:
            d (np.ndarray): Array of distances.
            length_scale (float): The length scale parameter.
            nu (float): The smoothness parameter.

        Returns:
            np.ndarray: Covariance values.
        """
        # Handle zero distances to avoid numerical issues
        d_safe = np.where(d == 0, 1e-12, d)

        # Matern formula components
        const = (2 ** (1 - nu)) / gamma(nu)
        arg = np.sqrt(2 * nu) * d_safe / length_scale

        # Calculate Matern covariance
        cov = const * (arg**nu) * kv(nu, arg)

        # Set covariance to 1 at zero distance
        cov = np.where(d == 0, 1.0, cov)

        return cov

    def generate_grf_covariance_method(grid_size, length_scale, nu, num_samples):
        """
        Generate GRF samples using covariance matrix and Cholesky decomposition.
        """
        # Create grid points
        x = np.linspace(0, 1, grid_size)
        y = np.linspace(0, 1, grid_size)
        xx, yy = np.meshgrid(x, y)
        grid_points = np.c_[xx.ravel(), yy.ravel()]

        # Calculate pairwise distance matrix
        distance_matrix = cdist(grid_points, grid_points)

        # Compute covariance matrix using Matern kernel
        K = matern_kernel_covariance(distance_matrix, length_scale, nu)

        # Add nugget for numerical stability
        K += 1e-6 * np.eye(grid_points.shape[0])

        # Cholesky decomposition
        L = np.linalg.cholesky(K)

        # Generate samples
        samples = []
        for _ in range(num_samples):
            u = np.random.randn(grid_points.shape[0])
            f = L @ u
            grf_sample = f.reshape((grid_size, grid_size))
            samples.append(grf_sample)

        return np.array(samples)

    def compute_average_spectral_energy(samples):
        """
        Compute the average spectral energy of GRF samples.
        """
        spectral_energies = []

        for sample in samples:
            # Compute 2D FFT
            fft_sample = fft2(sample)
            # Shift zero frequency to center
            fft_shifted = fftshift(fft_sample)
            # Compute power spectral density
            psd = np.abs(fft_shifted) ** 2
            spectral_energies.append(psd)

        # Average over all samples
        avg_spectral_energy = np.mean(spectral_energies, axis=0)
        return avg_spectral_energy

    def compute_radial_average(spectral_energy):
        """
        Compute radially averaged spectral energy.
        """
        h, w = spectral_energy.shape
        center_x, center_y = w // 2, h // 2

        # Create coordinate arrays
        y, x = np.ogrid[:h, :w]
        # Compute distance from center
        r = np.sqrt((x - center_x) ** 2 + (y - center_y) ** 2)

        # Bin by distance
        r_int = r.astype(int)
        max_r = min(center_x, center_y)

        radial_profile = []
        radii = []

        for radius in range(max_r):
            mask = r_int == radius
            if np.sum(mask) > 0:
                radial_profile.append(np.mean(spectral_energy[mask]))
                radii.append(radius)

        return np.array(radii), np.array(radial_profile)

    # Test parameters
    grid_size = 64
    length_scale = 0.1
    nu = 1.5
    num_samples = 500

    print(f"Testing Matern GRF comparison with grid_size={grid_size}, scale={length_scale}, nu={nu}")

    # Set random seed for reproducibility
    np.random.seed(42)
    torch.manual_seed(42)

    # Generate samples using covariance method
    print("Generating samples using covariance method...")
    covariance_samples = generate_grf_covariance_method(grid_size, length_scale, nu, num_samples)

    # Generate samples using spectral method
    print("Generating samples using spectral method...")
    spectral_sampler = MaternKernelSampler(in_channels=1, Ln1=grid_size, Ln2=grid_size, scale=length_scale, nu=nu, boundary_condition=boundary_condition, normalize_std=False)
    spectral_samples_tensor = spectral_sampler.sample(num_samples)
    spectral_samples = spectral_samples_tensor.squeeze(1).numpy()

    # Compute average spectral energies
    print("Computing spectral energies...")
    cov_spectral_energy = compute_average_spectral_energy(covariance_samples)
    spec_spectral_energy = compute_average_spectral_energy(spectral_samples)

    # Compute radial averages for comparison
    cov_radii, cov_radial = compute_radial_average(cov_spectral_energy)
    spec_radii, spec_radial = compute_radial_average(spec_spectral_energy)

    # Compare statistics
    print("\n=== Comparison Results ===")
    print(f"Covariance method - Sample mean: {np.mean(covariance_samples):.6f}, std: {np.std(covariance_samples):.6f}")
    print(f"Spectral method   - Sample mean: {np.mean(spectral_samples):.6f}, std: {np.std(spectral_samples):.6f}")

    # Compare total spectral energy
    total_cov_energy = np.sum(cov_spectral_energy)
    total_spec_energy = np.sum(spec_spectral_energy)
    print(f"Covariance method - Total spectral energy: {total_cov_energy:.2e}")
    print(f"Spectral method   - Total spectral energy: {total_spec_energy:.2e}")

    # Correlation between radial profiles
    correlation = np.corrcoef(cov_radial[1:], spec_radial[1:])[0, 1]
    print(f"Spectral profile correlation: {correlation:.3f}")

    # The correlation should be reasonably high (> 0.7) indicating similar spectral characteristics
    assert correlation > 0.99, f"Spectral profiles should be correlated, got {correlation:.3f}"


if __name__ == "__main__":
    pytest.main([__file__])
